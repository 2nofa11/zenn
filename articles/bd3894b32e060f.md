---
title: "CSRにおけるNuxtのデータフェッチ方法を比べてみる"
emoji: "😊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

## 導入部

Web開発をしていると、データフェッチをする機会は必ずと言っていいほど出くわす。
[フェッチ API](https://developer.mozilla.org/ja/docs/Web/API/Fetch_API)の`fetch()`を利用して通信を行う機会も多いが、データフェッチのコンポーザブル関数やライブラリが存在する。

## 課題提起

### 前提

Nuxtは、ユニバーサルレンダリングとクライアントサイドレンダリングの両方をサポートしています。今回はクライアントサイドレンダリングをベースに説明する。

### 比較対象

今回は以下の3つを比べてみて、どんな違いがあるのかを検証する

* [useAsyncData](https://nuxt.com/docs/4.x/api/composables/use-async-data)
  * Nuxtに標準で入っているコンポーザブル関数
* TanStack Query：[useQuery](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery)
  * 非同期状態管理、サーバー状態ユーティリティ、およびデータフェッチ機能を提供するヘッドレスなライブラリ。出自はReactのライブラリ。
* Pinia Colada：[useQuery](https://pinia-colada.esm.dev/guide/queries.html)
  * Piniaの状態管理機構を利用してTanStack QueryのuseQuery互換の機能を提供するライブラリ。

## 解決策

上記3つのメソッドは、シグネチャが似ているのでほぼ同じ書き味で記載することができます。それぞれ書いて動かしてみることでどこが違うのかを比較してみましょう。

## 実装例

### 準備

serverの返却値としては`server/api/posts.get.ts`として以下を用意しています。

```ts
// server/api/posts.get.ts
export default defineEventHandler((event) => {
  const query = getQuery(event)
  const limit = Number(query.limit ?? 10)
  return $fetch<Post[]>('http://jsonplaceholder.typicode.com/posts', {
    query: {
      _limit: limit
    }
  })
})
```

やっていることはとてもシンプルで、以下をやってると理解してください。

- GET /api/posts を受け取ったら、1 回の取得で何件の投稿を返すかのクエリ limit の値を取得する
- その limit を _limit として http://jsonplaceholder.typicode.com/posts へ $fetch する
- 外部 API のレスポンス（投稿一覧）をそのまま返す

### コード比較

コード全体も記載しますが、説明したい差分を中心に取り扱います。

#### useAsyncData

```ts
const limit = ref(10)
const key = computed(() => `posts-${limit.value}`)

const { data, status } = await useAsyncData(
  key,
  () =>
    $fetch('/api/posts', {
      query: { limit: limit.value }
    })
)
```

[useAsyncData - Reactive Keys](https://nuxt.com/docs/4.x/api/composables/use-async-data#reactive-keys)を参考にコードを書いてます。useAsyncDataのkeyにはstringを返すcomputed、ref、getter functionが使えます。
今回はcomputedを用いて表示件数（limit）の増減によってkeyが切り替わるようにしています。

#### TanStack Query：useQuery

```ts
const limit = ref(10)
const queryKey = computed(() => ['posts', limit.value])

const { data, status } = useQuery({
  queryKey,
  queryFn: () =>
    $fetch('/api/posts', {
      query: { limit: limit.value }
    })
})
```

queryKeyは配列でJSON.stringifyでシリアライズ可能なものを対象とできます。こちらもcomputedが使えるので表示件数（limit）の増減に渡します。

#### Pinia Colada：useQuery

```ts
const limit = ref(10)
const key = computed(() => ['posts', limit.value])

const { data, status } = useQuery({
  key,
  query: () =>
    $fetch('/api/posts', {
      query: { limit: limit.value }
    })
})
```

TanStack Query：useQueryとほとんど同じです。


#### 触ってみての比較

以下の動作ケースを試してみます。

①初期描画
②表示件数を10件→5件
③表示件数を5件→10件

#### useAsyncData

![useAsyncData](/images/bd3894b32e060f-useAsyncData.gif)

正しく投稿を取得できてますね。また、リクエストが計3回走っていることがわかります。
ポイントとしては、`③表示件数を5件→10件`のタイミングで、loading...`の表示が挟まっていると思います。

#### TanStack Query：useQuery

![TanStack Query：useQuery](/images/bd3894b32e060f-TanStackQuery.gif)

こちらもリクエストが計3回走っていることがわかります。
useAsyncDataと比べて、`③表示件数を5件→10件`のタイミングで、loading...`の表示発生していません！

これは、`useAsyncData`のstatus:は**データリクエストの状態を示します**。に対して、TanStack Query：useQueryのstatus は**データに関する情報**を示します。データリクエストに対するステータスは**fetchStatus**として別で定義されています。

#### Pinia Colada：useQuery

![Pinia Colada：useQuery](/images/bd3894b32e060f-PiniaColada.gif)

こちらはリクエストが計**2**回だけになってますね！
こちらは、staleTimeというキャッシュを利用可能な状態とみなすまでの時間がuseQueryはデフォルトで 5秒で設定されるため、リクエストを飛ばさないための挙動になってます。（TanStack QueryはデフォルトstaleTimeは0秒）

## 結論

TanStack QueryとPinia Colada、[TanStack QueryからPinia Coladaへのマイグレーションガイド](https://pinia-colada.esm.dev/cookbook/migration-tvq.html)も公式から提供されているほどなのでuseQueryの書き味はほぼ変わらないですね。

似たようなシグネチャを持っているのに細部が違うことがわかりました。比べてみると挙動が違うので面白かったです。

## 参考